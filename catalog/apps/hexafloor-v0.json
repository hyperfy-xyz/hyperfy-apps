{"script_excerpt":"const RADIUS = 1.4\nconst platform = app.get('Body')\napp.remove(platform)\n\n// Calculate the proper offsets for hexagonal tiling\nconst WIDTH = RADIUS * 2\nconst HEIGHT = WIDTH * Math.sqrt(3) / 2\n\n// Key control planes\nconst SIZE = 10\nlet patternIndex = 1\n\n// Parameters for pattern functions\nconst GRID_SIZE = 100\nconst SPACING = 0.2\nconst WAVE_SPEED = 1.5\nconst WAVE_HEIGHT = 1\nconst WAVE_FREQUENCY = 1.5\nconst BASE_HEIGHT = 0.1\n// const RADIUS = GRID_SIZE * 0.5 //couldn't get this to work :(\nconst WAVE_SPEED_MIN = 0.5\nconst WAVE_SPEED_MAX = 3.0\nconst WAVE_FREQ_MIN = 0.5\nconst WAVE_FREQ_MAX = 3.0\nlet isCircular = false\nlet intensity = 0.5  // Add intensity variable with default value\nlet waveSpeed = WAVE_SPEED  // Initialize with original constant\nlet waveFrequency = WAVE_FREQUENCY  // Initialize with original constant\nconst objects = [] // Container array for object control\n\nfor (let row = 0; row < SIZE; row++) {\n    const offset = row % 2 === 0 ? 0 : WIDTH / 2\n\n\t\n    for (let col = 0; col < SIZE; col++) {\n        let x = col * WIDTH + offset\n        let z = row * HEIGHT\n        const obj = platform.clone(true)\n        obj.position.set(\n            x,\n            0,\n            z\n        )\n\t\t\n\t\tobjects.push({\n\t\t\tnode: obj,\n\t\t\tbaseY: obj.position.y,\n\t\t\tx: x,\n\t\t\tz: z\n\t\t})\n    \n        app.add(obj)\n    }\n}\n\n// Define wave patterns\nconst patterns = [\n    // Pattern 0: Off (flat surface)\n    (obj, time) => {\n        return 0\n    },\n    // Pattern 1: Original ripple (modified to stay above base)\n    (obj, time) => {\n        const distance = Math.sqrt(obj.x * obj.x + obj.z * obj.z)\n        return Math.max(0, Math.sin(distance - time * WAVE_FREQUENCY))\n    },\n    // Pattern 2: Checkerboard\n    (obj, time) => {\n        return Math.max(0, Math.sin(time * WAVE_FREQUENCY + (obj.x + obj.z) * Math.PI))\n    },\n    // Pattern 3: Diagonal waves\n    (obj, time) => {\n        return Math.max(0, Math.sin(time * WAVE_FREQUENCY + (obj.x - obj.z) * 0.5))\n    },\n    // Pattern 4: Circular rings\n","script_path":"assets/27d9f2e03962d8db7ad657e60082a54509062e2a4554ad7caa81cadebdd3d33b.js","source_files":[{"path":"assets/27d9f2e03962d8db7ad657e60082a54509062e2a4554ad7caa81cadebdd3d33b.js","size_bytes":9876},{"path":"assets/7eee836a3d7e6a4828b246095dbed57aefd44cf392845fd44dddc10b9d81f280.glb","size_bytes":11476},{"path":"blueprint.json","size_bytes":444},{"path":"manifest.json","size_bytes":525}],"asset_files":["27d9f2e03962d8db7ad657e60082a54509062e2a4554ad7caa81cadebdd3d33b.js","7eee836a3d7e6a4828b246095dbed57aefd44cf392845fd44dddc10b9d81f280.glb"],"blueprint_path":"blueprint.json"}