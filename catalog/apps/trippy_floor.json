{"script_excerpt":"const template = app.get('Cube')  // Replace 'Cube' with your node name\nif (!template) {\n    console.error('Could not find Cube template')\n    return\n}\n\ntemplate.visible = false  // Hide the original template\n\nconst GRID_SIZE = 100\nconst SPACING = 1.0  // Space between objects\nconst WAVE_SPEED = 1.0\nconst WAVE_HEIGHT = 0.5\nconst WAVE_FREQUENCY = 2.0\nconst BASE_HEIGHT = 1.0\n\nconst objects = []\n\napp.on('update', () => {\n    // Skip if objects are already created\n    if (objects.length > 0) return\n    \n    // Create grid of objects\n    for (let x = 0; x < GRID_SIZE; x++) {\n        for (let z = 0; z < GRID_SIZE; z++) {\n            const obj = template.clone(true)\n            obj.visible = true\n            obj.scale.set(0.5, 0.5, 0.5)  // Scale down the object to half size\n            \n            // Calculate centered grid position\n            const offsetX = (x - GRID_SIZE/2) * SPACING\n            const offsetZ = (z - GRID_SIZE/2) * SPACING\n            obj.position.set(offsetX, 0, offsetZ)\n\n            objects.push({\n                node: obj,\n                baseY: obj.position.y,\n                x: x,\n                z: z\n            })\n            \n            app.add(obj)\n        }\n    }\n})\n\nlet patternIndex = 0\nconst patterns = [\n    // Pattern 0: Off (flat surface)\n    (obj, time) => {\n        return 0\n    },\n    // Pattern 1: Original ripple (modified to stay above base)\n    (obj, time) => {\n        const distance = Math.sqrt(obj.x * obj.x + obj.z * obj.z)\n        return Math.max(0, Math.sin(distance - time * WAVE_FREQUENCY))\n    },\n    // Pattern 2: Checkerboard\n    (obj, time) => {\n        return Math.max(0, Math.sin(time * WAVE_FREQUENCY + (obj.x + obj.z) * Math.PI))\n    },\n    // Pattern 3: Diagonal waves\n    (obj, time) => {\n        return Math.max(0, Math.sin(time * WAVE_FREQUENCY + (obj.x - obj.z) * 0.5))\n    },\n    // Pattern 4: Circular rings\n    (obj, time) => {\n        const distance = Math.sqrt(obj.x * obj.x + obj.z * obj.z)\n        return Math.max(0","script_path":"assets/b89a6ca4883ed232d33b29559b0dedde9c43a7f888a08bdf89a5b3d1ab1add90.js","source_files":[{"path":"assets/4bd5e491a03f3c6e19e593cc8151320a70edefef9377ddff9dccd50157ec8939.glb","size_bytes":2279968},{"path":"assets/b89a6ca4883ed232d33b29559b0dedde9c43a7f888a08bdf89a5b3d1ab1add90.js","size_bytes":9221},{"path":"blueprint.json","size_bytes":403},{"path":"manifest.json","size_bytes":527}],"asset_files":["4bd5e491a03f3c6e19e593cc8151320a70edefef9377ddff9dccd50157ec8939.glb","b89a6ca4883ed232d33b29559b0dedde9c43a7f888a08bdf89a5b3d1ab1add90.js"],"blueprint_path":"blueprint.json"}