{"script_excerpt":"if (world.isClient) {\n  // Configuration:\n  const safeDistance = 3;         // Distance threshold (in meters) for switching to avoid mode.\n  const followMargin = 0.5;       // Extra distance for switching back to follow mode.\n  const moveSpeed = 1;            // Movement speed (units per second) for following/avoiding.\n  const orbitSpeed = 1;           // Orbit (idle) speed when the player is stationary.\n  const rotationSpeed = 2;        // Rotation interpolation speed (radians per second)\n  const playerMovementThreshold = 0.01; // If the player's movement is below this, consider them stationary.\n  \n  // Track the current behavior mode. Start in \"follow\" mode.\n  let currentMode = \"follow\";\n  \n  // Store the player's last position for movement detection.\n  let lastPlayerPosition = null;\n  \n  app.on('update', delta => {\n    const player = world.getPlayer();\n    if (!player) return;\n    \n    // Initialize lastPlayerPosition if needed.\n    if (!lastPlayerPosition) {\n      lastPlayerPosition = player.position.clone();\n    }\n    \n    // Calculate the distance between the player and the object.\n    const distance = player.position.distanceTo(app.position);\n    \n    // Update mode based on distance with hysteresis:\n    if (currentMode === \"follow\" && distance < safeDistance) {\n      currentMode = \"avoid\";\n    } else if (currentMode === \"avoid\" && distance > safeDistance + followMargin) {\n      currentMode = \"follow\";\n    }\n    \n    // Determine how much the player moved since last frame.\n    const playerMovement = new Vector3().subVectors(player.position, lastPlayerPosition);\n    const playerSpeed = playerMovement.length();\n    \n    // Determine movement direction.\n    const moveDirection = new Vector3();\n    if (currentMode === \"avoid\") {\n      // If the player is nearly stationary, orbit around the player horizontally.\n      if (playerSpeed < playerMovementThreshold) {\n        const dirFromPlayer = new Vector3().subVectors(app.position, player.position);\n        dirFromPl","script_path":"assets/1e5819514d927b5e44cdf4527e723ddb5af096e2195e3504a67180dee6fb23ed.js","source_files":[{"path":"assets/1e5819514d927b5e44cdf4527e723ddb5af096e2195e3504a67180dee6fb23ed.js","size_bytes":3663},{"path":"assets/28a2e22801904ade0436588350af3b59174a4e129326f0e4b52f6474f9cf5383.glb","size_bytes":176868},{"path":"blueprint.json","size_bytes":484},{"path":"manifest.json","size_bytes":526}],"asset_files":["1e5819514d927b5e44cdf4527e723ddb5af096e2195e3504a67180dee6fb23ed.js","28a2e22801904ade0436588350af3b59174a4e129326f0e4b52f6474f9cf5383.glb"],"blueprint_path":"blueprint.json"}