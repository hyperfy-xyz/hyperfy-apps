{"script_excerpt":"const SIZE = 3 // Distance from one hexagon point to its opposite point\nconst RINGS = 10 // Number of rings to generate\nconst LAYERS = 6\nconst HEIGHT = 50 // meters above app where the bottom layer begins\nconst GAP = 10 // gap size between layers\n\nconst QUEUE_TIME = 15 // seconds\nconst START_TIME = 5 // seconds\n\nconst FORWARD = new Vector3(0, 0, -1)\n\nconst v1 = new Vector3()\nconst q1 = new Quaternion(0, 0, 0, 1)\nconst e1 = new Euler().reorder('YXZ')\n\nconst totalHexagons = (1 + 3 * RINGS * (RINGS + 1)) * LAYERS\n\nconst origin = new Vector3().copy(app.position)\n\nconst localPlayer = world.getPlayer()\n\nconst activeTpl = app.get('Active')\nconst fallingTpl = app.get('Falling')\nconst cageTpl = app.get('Cage')\nconst deathZone = app.get('DeathZone')\napp.remove(activeTpl)\napp.remove(fallingTpl)\napp.remove(cageTpl)\napp.remove(deathZone)\n\nconst maxRadius = ((SIZE * RINGS * 2) + SIZE) / 2\nconst deathZoneWidth = (maxRadius * 2) + 10\nconst deathZoneHeight = (LAYERS * GAP) + GAP + GAP\ndeathZone.position.set(0, HEIGHT + (deathZoneHeight / 2), 0)\ndeathZone.scale.set(deathZoneWidth, deathZoneHeight, deathZoneWidth)\n\nconsole.log('#hexagons', totalHexagons)\n\nif (world.isServer) {\n  const state = app.state\n\n  // generate hexagons\n  const hexagons = []\n  for (let i = 0; i < LAYERS; i++) {\n    const y = HEIGHT + (i * GAP)\n    generateLayer(pos => {\n      const idx = hexagons.length\n      pos.y += y\n      const hexagon = createHexagon(pos, playerId => {\n        state.hexagons[idx] = 1\n        app.send('trip', idx)\n      })\n      hexagons.push(hexagon)\n    })\n  }\n\n  // watch death zone\n  app.add(deathZone)\n  deathZone.onTriggerLeave = (e) => {\n    if (!e.playerId) return\n    if (!state.players.has(e.playerId)) return\n    if (state.phase !== 'play' && state.phase !== 'start') return\n    state.players.delete(e.playerId)\n    if (!state.players.size) {\n      const winner = state.phase === 'play'\n      state.phase = 'idle'\n      state.hexagons.fill(1)\n      for (const hexagon of hexagons) {\n      ","script_path":"assets/b711a53ef7d06001f11226612920ffaf8378142c9d37c1e088686ed4d393a5f6.js","source_files":[{"path":"assets/39ad1b405cbf41a90825dadf0b554f3c3baba634636bb94a1057dd8ec0784c86.png","size_bytes":2777},{"path":"assets/95c97d3047588515899ddbbb0df216abc303dc9f7f14b620ff77b190e40ada3a.glb","size_bytes":53888},{"path":"assets/b711a53ef7d06001f11226612920ffaf8378142c9d37c1e088686ed4d393a5f6.js","size_bytes":14787},{"path":"blueprint.json","size_bytes":594},{"path":"manifest.json","size_bytes":779}],"props":{"collision":true},"asset_files":["39ad1b405cbf41a90825dadf0b554f3c3baba634636bb94a1057dd8ec0784c86.png","95c97d3047588515899ddbbb0df216abc303dc9f7f14b620ff77b190e40ada3a.glb","b711a53ef7d06001f11226612920ffaf8378142c9d37c1e088686ed4d393a5f6.js"],"blueprint_path":"blueprint.json"}