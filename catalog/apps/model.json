{"script_excerpt":"export default function main(world, app, fetch, props, setTimeout) {\napp.configure([\n  {\n    key: 'scale',\n    type: 'number',\n    label: 'Scale',\n    min: 0,\n    dp: 2,\n    step: 0.1,\n    initial: 1,\n  },\n  {\n    key: 'collision',\n    type: 'switch',\n    label: 'Collision',\n    options: [\n      { label: 'No', value: false },\n      { label: 'Yes', value: true },\n    ],\n    initial: false\n  },\n])\n\nconst v1 = new Vector3()\nconst v2 = new Vector3()\nconst q1 = new Quaternion()\nconst m1 = new Matrix4()\n\n// scale entire app\napp.scale.setScalar(props.scale)\n\n// if collision enabled, make a rigidbody with colliders for each mesh\nif (props.collision) {\n  // clean to get updated transforms\n  app.clean()\n  // get app world inverse matrix\n  const appInverseMatrix = app.matrixWorld.clone().invert()\n  // create rigidbody\n  const body = app.create('rigidbody')\n  body.position.copy(app.position)\n  body.quaternion.copy(app.quaternion)\n  body.scale.copy(app.scale)\n  // create colliders\n  app.traverse(node => {\n    if (node.name === 'mesh') {\n      m1.copy(node.matrixWorld).premultiply(appInverseMatrix).decompose(v1, q1, v2)\n      const collider = app.create('collider')\n      collider.position.copy(v1)\n      collider.quaternion.copy(q1)\n      collider.scale.copy(v2)\n      collider.type = 'geometry'\n      collider.geometry = node.geometry\n      body.add(collider)\n    }\n  })\n  world.add(body)\n}\n}\n","script_path":"index.js","source_files":[{"path":"Model.json","size_bytes":320},{"path":"assets/model.glb","size_bytes":3376},{"path":"index.js","size_bytes":1399}],"props":{"collision":true,"scale":0.3},"asset_files":["model.glb"],"blueprint_path":"Model.json"}